var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/kythera/docs/getting-started/",title:"Getting Started",description:"",content:""}),e.add({id:1,href:"/kythera/docs/getting-started/introduction/",title:"Introduction",description:`Kythera is a toolset for Filecoin Virtual Machine Native Actor development, testing and deployment.
The ambition is to become the core boilerplate for any native projects developed in any FVM supported languages. its goal is to ease testing of native actors at the Wasm level, deploy the actors on any FVM-compatible network and interact with them.
Sections #Getting started
To get started with Kythera, install Kythera and setup your first project.`,content:`Kythera is a toolset for Filecoin Virtual Machine Native Actor development, testing and deployment.
The ambition is to become the core boilerplate for any native projects developed in any FVM supported languages. its goal is to ease testing of native actors at the Wasm level, deploy the actors on any FVM-compatible network and interact with them.
Sections #Getting started
To get started with Kythera, install Kythera and setup your first project.
Overview
This overview will give you all you need to know about how to use kythera to develop, test, deploy, and interact with smart contracts.
Tutorials
Tutorials on building actors with Kythera.
Use Kythera over a Rust-base native actors project Contributing
Help us improve Kythera by contributing
Reference
Test command Snapshot command Cheatcodes `}),e.add({id:2,href:"/kythera/docs/getting-started/installation/",title:"Installation",description:`Precompiled binaries #Precompiled binaries are available from the Github release page.
Building from source #You can build Kythera binary directly from our main repository through cargo:
\$ cargo install --git https://github.com/polyphene/kythera --force kythera `,content:`Precompiled binaries #Precompiled binaries are available from the Github release page.
Building from source #You can build Kythera binary directly from our main repository through cargo:
\$ cargo install --git https://github.com/polyphene/kythera --force kythera `}),e.add({id:3,href:"/kythera/docs/getting-started/first-steps/",title:"First Steps with Kythera",description:`This section provide a quick example of how to use the kythera command line tool. We demonstrate how to start up a Rust-based native actors project, compile and test it.
ðŸ—’ï¸ Note
Future base project for Assembly Script and Golang will soon be created to assist developers more familiar with those languages.
To start the development clone our dedicated Rust template:
\$ git clone https://github.com/polyphene/kythera-rs-starter.git Let\u0026rsquo;s see how the project layout looks like:`,content:"This section provide a quick example of how to use the kythera command line tool. We demonstrate how to start up a Rust-based native actors project, compile and test it.\nðŸ—’ï¸ Note\nFuture base project for Assembly Script and Golang will soon be created to assist developers more familiar with those languages.\nTo start the development clone our dedicated Rust template:\n$ git clone https://github.com/polyphene/kythera-rs-starter.git Let\u0026rsquo;s see how the project layout looks like:\n$ cd kythera-rs-starter $ tree . -d -L 1 . â”œâ”€â”€ actors â”œâ”€â”€ build-helper â”œâ”€â”€ target â””â”€â”€ tests 4 directories Now, we can simply build necessary assets through a simple `cargo build`: ```shell $ cargo build ... Finished dev [unoptimized + debuginfo] target(s) in 2m 10s ``` Once the source actors are compiled we can now run our tests: ```shell $ kythera test Running Tests for Actor : HelloWorld.wasm Testing 1 test files HelloWorld.t.wasm: testing 2 tests test TestConstructorSetup ... ok (gas consumption: 1519287) test TestMethodParameter ... ok (gas consumption: 2706032) test result: ok. 2 passed; 0 failed ``` ðŸ’¡ Tip\nYou can always print help for any subcommand (or their subcommands) by adding \u0026ndash;help at the end.\n"}),e.add({id:4,href:"/kythera/docs/overview/",title:"Overview",description:"",content:""}),e.add({id:5,href:"/kythera/docs/overview/kythera/",title:"Overview of Kythera",description:`Kythera is a command-line tool that provide basic utilities to work on native actors to bve deployed over the Filecoin network. Its main utilities revolve around:
Creating tests for core native actor logic and executing them. Provide a small and fast local execution environment to develop native actors. `,content:`Kythera is a command-line tool that provide basic utilities to work on native actors to bve deployed over the Filecoin network. Its main utilities revolve around:
Creating tests for core native actor logic and executing them. Provide a small and fast local execution environment to develop native actors. `}),e.add({id:6,href:"/kythera/docs/overview/tests/",title:"Tests",description:"",content:""}),e.add({id:7,href:"/kythera/docs/overview/tests/writing-tests/",title:"Writing tests",description:`Tests ran in Kythera are executed at the Wasm level. This effectively means that tests can be written in any language that supports compilation to this target. However, it is likely that when developing native actors a developer leverages the same language for both application actors and test actors.
In this section, we\u0026rsquo;ll go over the basic knowledge necessary to start implementing test actors in a Rust project.
Let\u0026rsquo;s take a look at a basic test:`,content:`Tests ran in Kythera are executed at the Wasm level. This effectively means that tests can be written in any language that supports compilation to this target. However, it is likely that when developing native actors a developer leverages the same language for both application actors and test actors.
In this section, we\u0026rsquo;ll go over the basic knowledge necessary to start implementing test actors in a Rust project.
Let\u0026rsquo;s take a look at a basic test:
// Copyright 2023 Polyphene. // SPDX-License-Identifier: Apache-2.0, MIT use cid::{multihash::Code, Cid}; use frc42_dispatch::match_method; use fvm_ipld_blockstore::Block; use fvm_ipld_encoding::tuple::{Deserialize_tuple, Serialize_tuple}; use fvm_ipld_encoding::DAG_CBOR; use fvm_sdk as sdk; use fvm_sdk::NO_DATA_BLOCK_ID; use fvm_shared::error::ExitCode; // Actor's state. #[derive(Serialize_tuple, Deserialize_tuple)] struct ActorState { value: u32, } impl ActorState { pub fn load(cid: \u0026amp;Cid) -\u0026gt; Self { let data = sdk::ipld::get(cid).unwrap(); fvm_ipld_encoding::from_slice::\u0026lt;Self\u0026gt;(\u0026amp;data).unwrap() } pub fn save(\u0026amp;self) -\u0026gt; Cid { let serialized = fvm_ipld_encoding::to_vec(self).unwrap(); let block = Block { codec: DAG_CBOR, data: serialized, }; sdk::ipld::put( Code::Blake2b256.into(), 32, block.codec, block.data.as_ref(), ) .unwrap() } } #[no_mangle] fn invoke(_input: u32) -\u0026gt; u32 { std::panic::set_hook(Box::new(|info| { sdk::vm::exit( ExitCode::USR_ASSERTION_FAILED.value(), None, Some(\u0026amp;format!(\u0026quot;{info}\u0026quot;)), ) })); let method_num = sdk::message::method_number(); match_method!( method_num, { \u0026quot;Constructor\u0026quot; =\u0026gt; { Constructor(); NO_DATA_BLOCK_ID }, \u0026quot;Setup\u0026quot; =\u0026gt; { Setup(); NO_DATA_BLOCK_ID }, \u0026quot;TestStateValue\u0026quot; =\u0026gt; { TestStateValue(); NO_DATA_BLOCK_ID }, \u0026quot;TestFailStateValue\u0026quot; =\u0026gt; { TestFailStateValue(); NO_DATA_BLOCK_ID }, _ =\u0026gt; { sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } #[allow(non_snake_case)] fn Constructor() { let state = ActorState { value: 1 }; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } #[allow(non_snake_case)] fn Setup() { let mut state = ActorState::load(\u0026amp;sdk::sself::root().unwrap()); state.value += 1; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } #[allow(non_snake_case)] fn TestStateValue() { let state = ActorState::load(\u0026amp;sdk::sself::root().unwrap()); let value = state.value; if state.value != 2u32 { sdk::vm::abort( ExitCode::USR_ASSERTION_FAILED.value(), Some(\u0026amp;format!(\u0026quot;expected value to be 2, got: {value}\u0026quot;)), ) } } #[allow(non_snake_case)] fn TestFailStateValue() { let state = ActorState::load(\u0026amp;sdk::sself::root().unwrap()); let value = state.value; if state.value != 4u32 { sdk::vm::abort( ExitCode::USR_ASSERTION_FAILED.value(), Some(\u0026amp;format!(\u0026quot;value properly not set to 4\u0026quot;)), ) } } Kythera uses the following keywords in tests:
SetUp: An optional function invoked after the actor Constructor and before each test case is run. #[allow(non_snake_case)] fn Setup() { let mut state = ActorState::load(\u0026amp;sdk::sself::root().unwrap()); state.value += 1; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } Test: Functions prefixed with test are run as a test case. #[allow(non_snake_case)] fn TestStateValue() { let state = ActorState::load(\u0026amp;sdk::sself::root().unwrap()); let value = state.value; if state.value != 2u32 { sdk::vm::abort( ExitCode::USR_ASSERTION_FAILED.value(), Some(\u0026amp;format!(\u0026quot;expected value to be 2, got: {value}\u0026quot;)), ) } } TestFail: The inverse of the Test prefix - if the function does not return an ExitCode::Ok, the test fails. #[allow(non_snake_case)] fn TestFailStateValue() { let state = ActorState::load(\u0026amp;sdk::sself::root().unwrap()); let value = state.value; if state.value != 4u32 { sdk::vm::abort( ExitCode::USR_ASSERTION_FAILED.value(), Some(\u0026amp;format!(\u0026quot;value properly not set to 4\u0026quot;)), ) } } Tests are deployed to the next highest actor ID available in the machine context, to ensure no overlap with external forked state. If an actor is interacted with within the tests the default sender will be the actor ID associated to the test actor.
`}),e.add({id:8,href:"/kythera/docs/overview/tests/cheatcodes/",title:"Cheatcodes",description:`Most of the time, simply testing your actors outputs isn\u0026rsquo;t enough. To manipulate the state of the blockchain, as well as test for specific edge cases, Kythera is shipped with a set of cheatcodes.
Cheatcodes allow you to change the block number, your identity, and more. They are invoked by calling specific functions on a specially designated actor ID: 98.
Let\u0026rsquo;s write an actor with a state that can only be updated by a selected actor ID, 250.`,content:"Most of the time, simply testing your actors outputs isn\u0026rsquo;t enough. To manipulate the state of the blockchain, as well as test for specific edge cases, Kythera is shipped with a set of cheatcodes.\nCheatcodes allow you to change the block number, your identity, and more. They are invoked by calling specific functions on a specially designated actor ID: 98.\nLet\u0026rsquo;s write an actor with a state that can only be updated by a selected actor ID, 250.\n// Copyright 2023 Polyphene. // SPDX-License-Identifier: Apache-2.0, MIT use cid::{multihash::Code, Cid}; use frc42_dispatch::match_method; use fvm_ipld_blockstore::Block; use fvm_ipld_encoding::tuple::{Deserialize_tuple, Serialize_tuple}; use fvm_ipld_encoding::DAG_CBOR; use fvm_ipld_encoding::{de::DeserializeOwned, RawBytes}; use fvm_sdk as sdk; use fvm_sdk::NO_DATA_BLOCK_ID; use fvm_shared::error::ExitCode; use sdk::sys::ErrorNumber; use serde::ser; use thiserror::Error; // Actor's state. #[derive(Serialize_tuple, Deserialize_tuple)] struct DemoActorState { value: u32, } impl DemoActorState { pub fn load(cid: \u0026amp;Cid) -\u0026gt; Self { let data = sdk::ipld::get(cid).unwrap(); fvm_ipld_encoding::from_slice::\u0026lt;Self\u0026gt;(\u0026amp;data).unwrap() } pub fn save(\u0026amp;self) -\u0026gt; Cid { let serialized = fvm_ipld_encoding::to_vec(self).unwrap(); let block = Block { codec: DAG_CBOR, data: serialized, }; sdk::ipld::put( Code::Blake2b256.into(), 32, block.codec, block.data.as_ref(), ) .unwrap() } } // IPLD Utils. #[derive(Error, Debug)] enum IpldError { #[error(\u0026quot;ipld encoding error: {0}\u0026quot;)] Encoding(#[from] fvm_ipld_encoding::Error), #[error(\u0026quot;ipld blockstore error: {0}\u0026quot;)] Blockstore(#[from] ErrorNumber), } // Util to save value in Block and return the block ID fn return_ipld\u0026lt;T\u0026gt;(value: \u0026amp;T) -\u0026gt; std::result::Result\u0026lt;u32, IpldError\u0026gt; where T: ser::Serialize + ?Sized, { let bytes = fvm_ipld_encoding::to_vec(value)?; Ok(sdk::ipld::put_block(DAG_CBOR, bytes.as_slice())?) } /// Deserialize message parameters into given struct. pub fn deserialize_params\u0026lt;D: DeserializeOwned\u0026gt;(params: u32) -\u0026gt; D { let params = fvm_sdk::message::params_raw(params) .expect(\u0026quot;Could not get message parameters\u0026quot;) .expect(\u0026quot;Expected message parameters but got none\u0026quot;); let params = RawBytes::new(params.data); params .deserialize() .expect(\u0026quot;Should be able to deserialize message params into arguments of called method\u0026quot;) } #[no_mangle] fn invoke(input: u32) -\u0026gt; u32 { std::panic::set_hook(Box::new(|info| { sdk::vm::abort(ExitCode::FIRST_USER_EXIT_CODE, Some(\u0026amp;format!(\u0026quot;{info}\u0026quot;))) })); let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;Constructor\u0026quot; =\u0026gt; { Constructor(); NO_DATA_BLOCK_ID }, \u0026quot;Read\u0026quot; =\u0026gt; { Read() }, \u0026quot;Write\u0026quot; =\u0026gt; { let write_value: u32 = deserialize_params(input); let caller: u64 = unsafe { fvm_sdk::sys::vm::message_context().unwrap().caller }; assert_eq!(caller, 250u64, \u0026quot;Only actor ID 250 can alter this value\u0026quot;); Write(write_value); NO_DATA_BLOCK_ID }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } #[allow(non_snake_case)] fn Constructor() { let state = DemoActorState { value: 1 }; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } #[allow(non_snake_case)] fn Read() -\u0026gt; u32 { let state = DemoActorState::load(\u0026amp;sdk::sself::root().unwrap()); return_ipld(\u0026amp;state.value).unwrap() } #[allow(non_snake_case)] fn Write(value: u32) { let mut state = DemoActorState::load(\u0026amp;sdk::sself::root().unwrap()); state.value = value; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } We can now write a basic test case against it:\n// Copyright 2023 Polyphene. // SPDX-License-Identifier: Apache-2.0, MIT use frc42_dispatch::match_method; use frc42_dispatch::method_hash; use fvm_ipld_encoding::ipld_block::IpldBlock; use fvm_ipld_encoding::DAG_CBOR; use fvm_ipld_encoding::{de::DeserializeOwned, RawBytes}; use fvm_sdk as sdk; use fvm_sdk::NO_DATA_BLOCK_ID; use fvm_shared::address::Address; use fvm_shared::bigint::Zero; use fvm_shared::econ::TokenAmount; use fvm_shared::error::ExitCode; use fvm_shared::sys::SendFlags; // IPLD Utils. /// Deserialize message parameters into given struct. pub fn deserialize_params\u0026lt;D: DeserializeOwned\u0026gt;(params: u32) -\u0026gt; D { let params = fvm_sdk::message::params_raw(params) .expect(\u0026quot;Could not get message parameters\u0026quot;) .expect(\u0026quot;Expected message parameters but got none\u0026quot;); let params = RawBytes::new(params.data); params .deserialize() .expect(\u0026quot;Should be able to deserialize message params into arguments of called method\u0026quot;) } #[no_mangle] fn invoke(input: u32) -\u0026gt; u32 { std::panic::set_hook(Box::new(|info| { sdk::vm::abort( ExitCode::USR_ASSERTION_FAILED.value(), Some(\u0026amp;format!(\u0026quot;{info}\u0026quot;)), ) })); let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;TestWrite\u0026quot; =\u0026gt; { TestWrite(input); NO_DATA_BLOCK_ID }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } #[allow(non_snake_case)] fn TestWrite(input: u32) { let target_actor_id: u64 = deserialize_params(input); // Try to write let new_value = 15u32; let res = fvm_sdk::send::send( \u0026amp;Address::new_id(target_actor_id), method_hash!(\u0026quot;Write\u0026quot;), Some(IpldBlock::serialize(DAG_CBOR, \u0026amp;new_value).unwrap()), TokenAmount::zero(), None, SendFlags::empty(), ) .unwrap(); assert_eq!(res.exit_code, ExitCode::OK); // Read let res = fvm_sdk::send::send( \u0026amp;Address::new_id(target_actor_id), method_hash!(\u0026quot;Read\u0026quot;), None, TokenAmount::zero(), None, SendFlags::empty(), ) .unwrap(); assert_eq!(res.exit_code, ExitCode::OK); let value: u32 = RawBytes::new( res.return_data .expect(\u0026quot;Should be able to read target actor\u0026quot;) .data, ) .deserialize() .unwrap(); assert_eq!(value, new_value); } If we run kythera test now, we will see that the test fails as the actor expects the send actor ID to be 250:\n$ kythera test ./artifacts Running Tests for Actor : Locked.wasm Testing 1 test files Locked.t.wasm: testing 1 tests test TestWrite ... FAILED (gas consumption: 2558341) failures: test TestWrite failed: message failed with backtrace: 00: f0104 (method 3427243882) -- panicked at 'assertion failed: `(left == right)` left: `ExitCode { value: 16 }`, right: `ExitCode { value: 0 }`', tests/locked-test/src/actor.rs:78:5 (24) 01: f0103 (method 254162321) -- panicked at 'assertion failed: `(left == right)` left: `104`, right: `250`: Only actor ID 250 can alter this value', actors/locked/src/actor.rs:109:17 (16) test result: FAILED. 0 passed; 1 failed Let\u0026rsquo;s add a step in the code to call our cheatcodes actor to prank the machine in thinking that we are actually the actor at ID 250:\n// ... #[allow(non_snake_case)] fn TestWrite(input: u32) { let target_actor_id: u64 = deserialize_params(input); // Prank machine with actor ID 250 let new_caller = Address::new_id(250); let res = fvm_sdk::send::send( \u0026amp;Address::new_id(98), method_hash!(\u0026quot;Prank\u0026quot;), Some(IpldBlock::serialize(DAG_CBOR, \u0026amp;new_caller).unwrap()), TokenAmount::zero(), None, SendFlags::empty(), ) .unwrap(); assert_eq!(res.exit_code, ExitCode::OK); // ... } Now, if we run kythera test again:\n$ kythera test ./artifacts Running Tests for Actor : Locked.wasm Testing 1 test files Locked.t.wasm: testing 1 tests test TestWrite ... ok (gas consumption: 5796750) test result: ok. 1 passed; 0 failed ðŸ“š Reference\nSee the Cheatcodes Reference for a complete overview of all the available cheatcodes.\n"}),e.add({id:9,href:"/kythera/docs/overview/tests/traces/",title:"Understanding traces",description:`Kythera can produce traces either for failing test (-vv) or all tests (-vvv).
Traces follow the same general format:
â”œâ”€ [\u0026lt;Gas Charge\u0026gt;] OnChainMessage â”‚ â””â”€ â† \u0026lt;Charging message value\u0026gt; â”œâ”€ [\u0026lt;Call\u0026gt;] from 102 to f0104 method: \u0026lt;Method number callled\u0026gt; â”œâ”€ [\u0026lt;Gas Charge\u0026gt;] OnMethodInvocation â”‚ â””â”€ â† 75000.000 â”œâ”€ [\u0026lt;Gas Charge\u0026gt;] \u0026lt;Gas charge reason\u0026gt; â”‚ â””â”€ â† \u0026lt;Gas charge value\u0026gt; ... â””â”€ â† \u0026lt;Execution exit code\u0026gt; Each call can have many more subcalls, each denoting a new message sent to another actor and a returned value.`,content:`Kythera can produce traces either for failing test (-vv) or all tests (-vvv).
Traces follow the same general format:
â”œâ”€ [\u0026lt;Gas Charge\u0026gt;] OnChainMessage â”‚ â””â”€ â† \u0026lt;Charging message value\u0026gt; â”œâ”€ [\u0026lt;Call\u0026gt;] from 102 to f0104 method: \u0026lt;Method number callled\u0026gt; â”œâ”€ [\u0026lt;Gas Charge\u0026gt;] OnMethodInvocation â”‚ â””â”€ â† 75000.000 â”œâ”€ [\u0026lt;Gas Charge\u0026gt;] \u0026lt;Gas charge reason\u0026gt; â”‚ â””â”€ â† \u0026lt;Gas charge value\u0026gt; ... â””â”€ â† \u0026lt;Execution exit code\u0026gt; Each call can have many more subcalls, each denoting a new message sent to another actor and a returned value.
`}),e.add({id:10,href:"/kythera/docs/overview/gas/",title:"Gas tracking",description:"",content:""}),e.add({id:11,href:"/kythera/docs/overview/gas/reports/",title:"Gas Reports",description:`Kythera can produce gas reports for your contracts. To show gas reports just pass the --gas-report argument while testing your actor.
Example output:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ Basic.wasm contract â”† â”† â”† â”† â”† â”‚ â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡ â”‚ Function Name â”† min â”† max â”† avg â”† median â”† # calls â”‚ â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤ â”‚ Constructor â”† 2385055 â”† 2385055 â”† 2385055 â”† 2385055 â”† 1 â”‚ â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤ â”‚ HelloWorld â”† 665472800 â”† 665472800 â”† 665472800 â”† 665472800 â”† 1 â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ `,content:`Kythera can produce gas reports for your contracts. To show gas reports just pass the --gas-report argument while testing your actor.
Example output:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ Basic.wasm contract â”† â”† â”† â”† â”† â”‚ â•žâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•¡ â”‚ Function Name â”† min â”† max â”† avg â”† median â”† # calls â”‚ â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤ â”‚ Constructor â”† 2385055 â”† 2385055 â”† 2385055 â”† 2385055 â”† 1 â”‚ â”œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¼â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ”¤ â”‚ HelloWorld â”† 665472800 â”† 665472800 â”† 665472800 â”† 665472800 â”† 1 â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ `}),e.add({id:12,href:"/kythera/docs/overview/gas/snapshots/",title:"Gas Snapshots",description:`Kythera can generate gas snapshots for all your test functions. This can be useful to get a general feel for how much gas your contract will consume, or to compare gas usage before and after various optimizations.
To generate the gas snapshot, run kythera snapshot \u0026lt;Path to artifacts\u0026gt;.
This will generate a file called .gas-snapshot by default with all your tests and their respective gas usage.
\$ kythera snapshot ./artifacts \$ cat .`,content:`Kythera can generate gas snapshots for all your test functions. This can be useful to get a general feel for how much gas your contract will consume, or to compare gas usage before and after various optimizations.
To generate the gas snapshot, run kythera snapshot \u0026lt;Path to artifacts\u0026gt;.
This will generate a file called .gas-snapshot by default with all your tests and their respective gas usage.
\$ kythera snapshot ./artifacts \$ cat .gas-snapshot name,cost,passed Basic.wasm::TestConstructorSetup,1519299,true Basic.wasm::TestMethodParameter,2707176,true Basic.wasm::TestFailed,1306487,false Basic.wasm::TestFailFailed,1229328,false Basic.wasm::TestFailSuccess,1306503,true The format of the file is a CSV file containing three columns:
name: identifier of the method for the given CSV line, in the format \u0026lt;Actor name\u0026gt;.wasm::\u0026lt;Method name\u0026gt;. cost: gas cost to run the test method. passed: boolean representing if the test was successful or not. Comparing gas usage #If you would like to compare the current snapshot file with your latest changes, you can use the --diff or --check options.
--diff will compare against the snapshot and display changes from the snapshot.
It can also optionally take a file name (--diff \u0026lt;FILE_NAME\u0026gt;), with the default being .gas-snapshot.
For example:
\$ kythera snapshot ./artifacts --diff Basic.t.wasm: testing 5 tests Generating gas snapshot Basic.wasm::TestConstructorSetup: gas used is 0% more Basic.wasm::TestMethodParameter: gas used is the same: 2707176 Basic.wasm::TestFailed: gas used is 6% less Basic.wasm::TestFailFailed: gas used is the same: 1229328 Basic.wasm::TestFailSuccess: gas used is the same: 1306503 Total gas dif: -77111 --check will execute the exact same logic but will exit with an exit code 1 if a difference is found.
`}),e.add({id:13,href:"/kythera/docs/reference/",title:"Reference",description:"",content:""}),e.add({id:14,href:"/kythera/docs/reference/kythera-test/",title:"kythera test",description:`NAME #kythera-test-command - Run the artifact\u0026rsquo;s tests.
DESCRIPTION #This Rust command represents the CLI arguments for the Kythera test command.
USAGE #kythera test [OPTIONS] \u0026lt;Path to artifacts\u0026gt; OPTIONS #--verbosity, -v
Set the verbosity level of the traces. Increase the verbosity by passing multiple times (e.g., -v, -vv, -vvv).
Verbosity levels:
2: Print execution traces for failing tests. 3: Print execution traces for all tests. --gas-report
Print gas reports.`,content:`NAME #kythera-test-command - Run the artifact\u0026rsquo;s tests.
DESCRIPTION #This Rust command represents the CLI arguments for the Kythera test command.
USAGE #kythera test [OPTIONS] \u0026lt;Path to artifacts\u0026gt; OPTIONS #--verbosity, -v
Set the verbosity level of the traces. Increase the verbosity by passing multiple times (e.g., -v, -vv, -vvv).
Verbosity levels:
2: Print execution traces for failing tests. 3: Print execution traces for all tests. --gas-report
Print gas reports.
EXAMPLE #Run the tests: kythera test path/to/artifacts Run the test and print all traces with gas reports: kythera test -vvv --gas-report path/to/artifacts `}),e.add({id:15,href:"/kythera/docs/reference/kythera-snapshot/",title:"kythera snapshot",description:`NAME #kythera-snapshot - Run the Kythera snapshot command.
DESCRIPTION #This Rust command represents the CLI arguments for the Kythera snapshot command.
USAGE #kythera snapshot [OPTIONS] \u0026lt;Path to artifacts\u0026gt; OPTIONS #--snap \u0026lt;FILE\u0026gt;
Output file for the gas snapshot. (Default: .gas-snapshot)
--diff \u0026lt;FILE\u0026gt;
Output a diff against a pre-existing snapshot. By default, the comparison is done with .gas-snapshot.
--check \u0026lt;FILE\u0026gt;
Compare against a pre-existing snapshot, exiting with code 1 if they do not match.`,content:`NAME #kythera-snapshot - Run the Kythera snapshot command.
DESCRIPTION #This Rust command represents the CLI arguments for the Kythera snapshot command.
USAGE #kythera snapshot [OPTIONS] \u0026lt;Path to artifacts\u0026gt; OPTIONS #--snap \u0026lt;FILE\u0026gt;
Output file for the gas snapshot. (Default: .gas-snapshot)
--diff \u0026lt;FILE\u0026gt;
Output a diff against a pre-existing snapshot. By default, the comparison is done with .gas-snapshot.
--check \u0026lt;FILE\u0026gt;
Compare against a pre-existing snapshot, exiting with code 1 if they do not match. Outputs a diff if the snapshots do not match. By default, the comparison is done with .gas-snapshot.
EXAMPLE #Generate a gas snapshot: kythera snapshot path/to/artifacts Generate a gas snapshot and output a diff against a pre-existing snapshot: kythera snapshot --diff existing-snapshot.path path/to/artifacts Compare against a pre-existing snapshot and output a diff if they don\u0026rsquo;t match: kythera snapshot --check existing-snapshot.path path/to/artifacts `}),e.add({id:16,href:"/kythera/docs/reference/cheatcodes/",title:"Cheatcodes",description:`Actor ID #Kythera will always deploy the cheatcode actor at the ID 98
List #The following cheatcodes are exposed through the actor:
Name Arguments Description Epoch i64 Set the NetworkContext::epoch Warp u64 Set the NetworkContext::timestamp Fee (u64, u64) Set the NetworkContext::fee ChaindId u64 Set the NetworkContext::chain_id Prank Address Sets the next implicit message\u0026rsquo;s MessageContext::caller to be the input address Trick Address Sets the next implicit message and its sub-implicit messages\u0026rsquo; MessageContext::origin to be the input address `,content:`Actor ID #Kythera will always deploy the cheatcode actor at the ID 98
List #The following cheatcodes are exposed through the actor:
Name Arguments Description Epoch i64 Set the NetworkContext::epoch Warp u64 Set the NetworkContext::timestamp Fee (u64, u64) Set the NetworkContext::fee ChaindId u64 Set the NetworkContext::chain_id Prank Address Sets the next implicit message\u0026rsquo;s MessageContext::caller to be the input address Trick Address Sets the next implicit message and its sub-implicit messages\u0026rsquo; MessageContext::origin to be the input address `}),e.add({id:17,href:"/kythera/docs/tutorials/",title:"Tutorials",description:"",content:""}),e.add({id:18,href:"/kythera/docs/tutorials/overview/",title:"Overview",description:`In this section of the documentation our goal is to list intersting tutorials that could prove useful for developers wanting to use Kythera in their native actors projects.
List #Rust Tutorial
Base Rust tutorial to assist any Rust developer in starting a project from scratch.
ðŸš€ Contributing
If you are a developer, and you want to help us set in place tutorials that feel relevant, feel free to refer to our contributing section to set it up!`,content:`In this section of the documentation our goal is to list intersting tutorials that could prove useful for developers wanting to use Kythera in their native actors projects.
List #Rust Tutorial
Base Rust tutorial to assist any Rust developer in starting a project from scratch.
ðŸš€ Contributing
If you are a developer, and you want to help us set in place tutorials that feel relevant, feel free to refer to our contributing section to set it up!
`}),e.add({id:19,href:"/kythera/docs/tutorials/rust/",title:"Rust Tutorial",description:"In the following tutorial our goal will be to",content:`In the following tutorial our goal will be to
`}),e.add({id:20,href:"/kythera/docs/tutorials/rust/requirements/",title:"Requirements",description:`Before creating our own actor along with its test we need to ensure that we have properly set the development environment.
Cloning starter project #To initialize the development environment, clone our dedicated Rust template:
\$ git clone https://github.com/polyphene/kythera-rs-starter.git Let\u0026rsquo;s see how the project layout looks like:
\$ cd kythera-rs-starter \$ tree . -d -L 1 . â”œâ”€â”€ actors â”œâ”€â”€ build-helper â””â”€â”€ tests 3 directories Each folder has its own use:`,content:`Before creating our own actor along with its test we need to ensure that we have properly set the development environment.
Cloning starter project #To initialize the development environment, clone our dedicated Rust template:
\$ git clone https://github.com/polyphene/kythera-rs-starter.git Let\u0026rsquo;s see how the project layout looks like:
\$ cd kythera-rs-starter \$ tree . -d -L 1 . â”œâ”€â”€ actors â”œâ”€â”€ build-helper â””â”€â”€ tests 3 directories Each folder has its own use:
build-helper: crate dedicated to the generation of artifacts for Kythera to run over the Rust project actors: folder that will contain all of our project actors tests: folder that will contain all the tests for our actors Build #Let\u0026rsquo;s ensure that this environment works properly by running cargo build:
\$ cargo build ... Finished dev [unoptimized + debuginfo] target(s) in 2m 10s We can notice that the layout for the project has changed: Let\u0026rsquo;s see how the project layout looks like:
\$ cd kythera-rs-starter \$ tree . -d -L 1 . â”œâ”€â”€ actors â”œâ”€â”€ artifacts â”œâ”€â”€ build-helper â”œâ”€â”€ target â””â”€â”€ tests 5 directories This new artifacts folder contains all the necessary files for Kythera to run the tests:
.wasm \u0026amp; .t.wasm: files that contains the Wasm bytecode for our actors and their tests .cbor \u0026amp; .t.cbor: CBOR encoded files that contains a description of the interface exposed by a related Wasm file Test #We can then run kythera test:
\$ kythera test ./artifacts Running Tests for Actor : HelloWorld.wasm Testing 1 test files HelloWorld.t.wasm: testing 2 tests test TestConstructorSetup ... ok (gas consumption: 1519287) test TestMethodParameter ... ok (gas consumption: 2706032) test result: ok. 2 passed; 0 failed As we are sure that our environment is ready we can now create our own actor.
`}),e.add({id:21,href:"/kythera/docs/tutorials/rust/actor/",title:"Create an actor",description:`As we previously mentioned, all of our native actors will have to be created in the actors folder.
An actor takes the shape of a Rust crate. In the starter you cloned you should already be able to find one crate, hello-world.
Configuring the actor crate #To proceed, we will copy the crate to make it ours:
\$ cp -r actors/hello-world/ actors/basic-actor \$ cd actors/basic-actor/ \u0026amp;\u0026amp; ls -la total 36 .`,content:`As we previously mentioned, all of our native actors will have to be created in the actors folder.
An actor takes the shape of a Rust crate. In the starter you cloned you should already be able to find one crate, hello-world.
Configuring the actor crate #To proceed, we will copy the crate to make it ours:
\$ cp -r actors/hello-world/ actors/basic-actor \$ cd actors/basic-actor/ \u0026amp;\u0026amp; ls -la total 36 . .. Cargo.lock Cargo.toml src First, let\u0026rsquo;s have a look to the Cargo.toml:
[package] name = \u0026quot;hello-world\u0026quot; version = \u0026quot;0.1.0\u0026quot; edition = \u0026quot;2021\u0026quot; [target.'cfg(target_arch = \u0026quot;wasm32\u0026quot;)'.dependencies] cid = { version = \u0026quot;0.8.5\u0026quot;, default-features = false } frc42_dispatch = \u0026quot;3.1.0\u0026quot; fvm_sdk = { version = \u0026quot;3.0.0\u0026quot; } fvm_shared = { version = \u0026quot;3.1.0\u0026quot; } fvm_ipld_blockstore = \u0026quot;0.1.1\u0026quot; fvm_ipld_encoding = { version = \u0026quot;0.3.3\u0026quot; } serde = { version = \u0026quot;1.0.136\u0026quot;, features = [\u0026quot;derive\u0026quot;] } serde_tuple = { version = \u0026quot;0.5.0\u0026quot; } thiserror = { version = \u0026quot;1.0.31\u0026quot; } [lib] crate-type = [\u0026quot;cdylib\u0026quot;] Two things to note:
Dependencies are specified under target.'cfg(target_arch = \u0026quot;wasm32\u0026quot;)'. This is because our crate will end up being compiled to Wasm, so we can focus on specifying dependencies for this target. We are specifying crate-type = [\u0026quot;cdylib\u0026quot;]. This is mandatory to be able to properly compile to the wasm32 target. To ensure that there are no overlapping, let\u0026rsquo;s change the crate name to basic-actor:
[package] name = \u0026quot;basic-actor\u0026quot; version = \u0026quot;0.1.0\u0026quot; edition = \u0026quot;2021\u0026quot; Actor\u0026rsquo;s development #For this tutorial, we will create an actor that stores a value updated through the call of an Add() method. It should also be possible to read the current value through a Read() method.
Layout #Our main logic for the actor will be located in src/actor.rs. The content of the file copied from hello-world is the following:
use cid::{multihash::Code, Cid}; use frc42_dispatch::match_method; use fvm_ipld_blockstore::Block; use fvm_ipld_encoding::tuple::{Deserialize_tuple, Serialize_tuple}; use fvm_ipld_encoding::DAG_CBOR; use fvm_sdk::sys::ErrorNumber; use fvm_sdk::NO_DATA_BLOCK_ID; use fvm_shared::error::ExitCode; use serde::ser; use thiserror::Error; // Actor's state. #[derive(Serialize_tuple, Deserialize_tuple)] struct ActorState { who_am_i: String, } impl ActorState { pub fn load(cid: \u0026amp;Cid) -\u0026gt; Self { let data = fvm_sdk::ipld::get(cid).unwrap(); fvm_ipld_encoding::from_slice::\u0026lt;Self\u0026gt;(\u0026amp;data).unwrap() } pub fn save(\u0026amp;self) -\u0026gt; Cid { let serialized = fvm_ipld_encoding::to_vec(self).unwrap(); let block = Block { codec: DAG_CBOR, data: serialized, }; fvm_sdk::ipld::put( Code::Blake2b256.into(), 32, block.codec, block.data.as_ref(), ) .unwrap() } } // IPLD Utils. #[derive(Error, Debug)] enum IpldError { #[error(\u0026quot;ipld encoding error: {0}\u0026quot;)] Encoding(#[from] fvm_ipld_encoding::Error), #[error(\u0026quot;ipld blockstore error: {0}\u0026quot;)] Blockstore(#[from] ErrorNumber), } fn return_ipld\u0026lt;T\u0026gt;(value: \u0026amp;T) -\u0026gt; std::result::Result\u0026lt;u32, IpldError\u0026gt; where T: ser::Serialize + ?Sized, { let bytes = fvm_ipld_encoding::to_vec(value)?; Ok(fvm_sdk::ipld::put_block(DAG_CBOR, bytes.as_slice())?) } #[no_mangle] fn invoke(_input: u32) -\u0026gt; u32 { let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;Constructor\u0026quot; =\u0026gt; { Constructor(); NO_DATA_BLOCK_ID }, \u0026quot;HelloWorld\u0026quot; =\u0026gt; { HelloWorld() }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } // \`Constructor\` for the actor, called at every instantiation. #[allow(non_snake_case)] fn Constructor() { let state = ActorState { who_am_i: String::from(\u0026quot;Basic Target Actor\u0026quot;), }; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } #[allow(non_snake_case)] fn HelloWorld() -\u0026gt; u32 { let state = ActorState::load(\u0026amp;fvm_sdk::sself::root().unwrap()); return_ipld(\u0026amp;state.who_am_i).unwrap() } There are a few methods that are interesting to note:
ActorState::load() \u0026amp; ActorState::save(): Method implemented over the structure representing the inner state of an actor. They are used to read and write the current state. return_ipld(): Method used to format a payload into an IPLD block and pass its ID as a return value for the received message. invoke(): Method that serves as the main entry point for our actor. It contains a match where each variant represents a call to an inner method of our actor. Constructor(): Method called at instantiation time of our actor in the machine. Storage: ActorState #To add both Add() and Read() to our actor we need to create the related methods and add their variant to our match in invoke(). But first, let\u0026rsquo;s change the state associated to our actor.
We need to change our state to store a counter instead of the who_am_i property.
#[derive(Serialize_tuple, Deserialize_tuple)] struct ActorState { value: u64, } impl ActorState { pub fn load(cid: \u0026amp;Cid) -\u0026gt; Self { let data = fvm_sdk::ipld::get(cid).unwrap(); fvm_ipld_encoding::from_slice::\u0026lt;Self\u0026gt;(\u0026amp;data).unwrap() } pub fn save(\u0026amp;self) -\u0026gt; Cid { let serialized = fvm_ipld_encoding::to_vec(self).unwrap(); let block = Block { codec: DAG_CBOR, data: serialized, }; fvm_sdk::ipld::put( Code::Blake2b256.into(), 32, block.codec, block.data.as_ref(), ) .unwrap() } } Then, update the Constructor() to properly initialize the state:
// \`Constructor\` for the actor, called at every instantiation. #[allow(non_snake_case)] fn Constructor() { let state = ActorState { value: 0, }; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } View method: Read #Let\u0026rsquo;s remove the HelloWorld variant from our invoke match and the inner method HelloWorld() from src/actor.rs:
// ... #[no_mangle] fn invoke(_input: u32) -\u0026gt; u32 { let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;Constructor\u0026quot; =\u0026gt; { Constructor(); NO_DATA_BLOCK_ID }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } // \`Constructor\` for the actor, called at every instantiation. #[allow(non_snake_case)] fn Constructor() { let state = ActorState { who_am_i: String::from(\u0026quot;Basic Target Actor\u0026quot;), }; let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } Then, add the match variant and the method:
// ... #[no_mangle] fn invoke(_input: u32) -\u0026gt; u32 { let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;Constructor\u0026quot; =\u0026gt; { Constructor(); NO_DATA_BLOCK_ID }, \u0026quot;Read\u0026quot; =\u0026gt; { Read() }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } // ... // \`Read\` returns the current value of our state value. #[allow(non_snake_case)] fn Read() -\u0026gt; u32 { let state = ActorState::load(\u0026amp;fvm_sdk::sself::root().unwrap()); return_ipld(\u0026amp;state.value).unwrap() } By leveraging the return_ipld(), we can return the value of ActorState::value to the caller.
Write method: Add #Finally, let\u0026rsquo;s add our Add() method to update the state of the actor. We are aiming to update the value of ActorState::value everytime the method is called by adding the passed value to the current state value.
The first thing we need is a way to fetch the arguments passed to the message received:
use fvm_ipld_encoding::{de::DeserializeOwned, RawBytes}; // ... /// Deserialize message parameters into given struct. pub fn deserialize_params\u0026lt;D: DeserializeOwned\u0026gt;(params: u32) -\u0026gt; D { let params = fvm_sdk::message::params_raw(params) .expect(\u0026quot;Could not get message parameters\u0026quot;) .expect(\u0026quot;Expected message parameters but got none\u0026quot;); let params = RawBytes::new(params.data); params .deserialize() .expect(\u0026quot;Should be able to deserialize message params into arguments of called method\u0026quot;) } deserialize_params takes the u32 value passed to the invoke() method and deserialize it in the type expected by the receiving variable.
We can now implement our Add() method and its invoke() match variant:
#[no_mangle] fn invoke(input: u32) -\u0026gt; u32 { let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;Constructor\u0026quot; =\u0026gt; { Constructor(); NO_DATA_BLOCK_ID }, \u0026quot;Read\u0026quot; =\u0026gt; { Read() }, \u0026quot;Add\u0026quot; =\u0026gt; { let to_add: u64 = deserialize_params(input); Add(to_add); NO_DATA_BLOCK_ID }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } // ... // \`Add\` will add the passed value to the current state. #[allow(non_snake_case)] fn Add(to_add: u64) { // Load the current state. let mut state = ActorState::load(\u0026amp;fvm_sdk::sself::root().unwrap()); // Add message value. state.value += to_add; // Save updated state. let cid = state.save(); fvm_sdk::sself::set_root(\u0026amp;cid).unwrap(); } With this method implemented, the interface of our actor corresponds to our intended design. However, to ensure that things works as intended we need to add tests to our project. This is what we will focus on during the next step.
`}),e.add({id:22,href:"/kythera/docs/tutorials/rust/test/",title:"Test our actor",description:`In this final step of our basic Rust tutorial we will go over the creation of tests for our basic-actor.
Configuring the test actor crate #As we configured our basic-actor crate, we need to configure a basic-actor-test crate. To do, we will copy the hello-world-test crate:
\$ cp -r tests/hello-world-test/ tests/basic-actor-test Then, update its crate name:
[package] name = \u0026quot;basic-actor-test\u0026quot; version = \u0026quot;0.1.0\u0026quot; edition = \u0026quot;2021\u0026quot; [target.'cfg(target_arch = \u0026quot;wasm32\u0026quot;)'.dependencies] cid = { version = \u0026quot;0.`,content:`In this final step of our basic Rust tutorial we will go over the creation of tests for our basic-actor.
Configuring the test actor crate #As we configured our basic-actor crate, we need to configure a basic-actor-test crate. To do, we will copy the hello-world-test crate:
\$ cp -r tests/hello-world-test/ tests/basic-actor-test Then, update its crate name:
[package] name = \u0026quot;basic-actor-test\u0026quot; version = \u0026quot;0.1.0\u0026quot; edition = \u0026quot;2021\u0026quot; [target.'cfg(target_arch = \u0026quot;wasm32\u0026quot;)'.dependencies] cid = { version = \u0026quot;0.8.5\u0026quot;, default-features = false } frc42_dispatch = \u0026quot;3.1.0\u0026quot; fvm_sdk = { version = \u0026quot;3.0.0\u0026quot; } fvm_shared = { version = \u0026quot;3.1.0\u0026quot; } fvm_ipld_blockstore = \u0026quot;0.1.1\u0026quot; fvm_ipld_encoding = { version = \u0026quot;0.3.3\u0026quot; } serde = { version = \u0026quot;1.0.136\u0026quot;, features = [\u0026quot;derive\u0026quot;] } serde_tuple = { version = \u0026quot;0.5.0\u0026quot; } thiserror = { version = \u0026quot;1.0.31\u0026quot; } [lib] crate-type = [\u0026quot;cdylib\u0026quot;] Test Actor\u0026rsquo;s development #To demonstrate the capabilities of Kythera we will create two tests: TestAdd() and TestFailAddArgumentType(). They should respectively:
TestAdd(): Should test that our Add() method happy path works as intended. TestFailAddArgumentType(): Should assert that a message sent with a wrong argument type will return a non 0 exit code. ðŸ—’ï¸ Note
The core layout of a test actor is the same as the one from our actor. The only difference is that in a test actor a new dedicated method can be added, Setup(). This setup method is called before each test of the test actor is invoked.
Test method: TestAdd #Before starting to code our two test methods, we need to ensure that we clean the invoke() method and the leftover methods from hello-world-test. We also won\u0026rsquo;t be needing Constructor(), Setup() or a dedicated ActorState in this tutorial.
// ... #[no_mangle] fn invoke(input: u32) -\u0026gt; u32 { std::panic::set_hook(Box::new(|info| { fvm_sdk::vm::exit( ExitCode::USR_ASSERTION_FAILED.value(), None, Some(\u0026amp;format!(\u0026quot;{info}\u0026quot;)), ) })); let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } We can now add our TestAdd() method to assert that our native actor works properly. To send a message to it, we can leverage the argument passed in message sent to our test actor. It contains the actor ID at which the actor was deployed.
use fvm_ipld_encoding::ipld_block::IpldBlock; // ... #[no_mangle] fn invoke(input: u32) -\u0026gt; u32 { std::panic::set_hook(Box::new(|info| { fvm_sdk::vm::exit( ExitCode::USR_ASSERTION_FAILED.value(), None, Some(\u0026amp;format!(\u0026quot;{info}\u0026quot;)), ) })); let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;TestAdd\u0026quot; =\u0026gt; { TestAdd(input); NO_DATA_BLOCK_ID }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } // Tests that the actor properly adds a passed value to its state. #[allow(non_snake_case)] fn TestAdd(input: u32) { // Get basic actor ID. let basic_actor_id: u64 = deserialize_params(input); // Value to add to state. let to_add = 10000u64; // Send message to add value to actor's state. let res = fvm_sdk::send::send( \u0026amp;Address::new_id(basic_actor_id), method_hash!(\u0026quot;Add\u0026quot;), Some(IpldBlock::serialize(DAG_CBOR, \u0026amp;to_add).unwrap()), TokenAmount::zero(), None, SendFlags::empty(), ) .unwrap(); // Assert message went through. assert_eq!(res.exit_code, ExitCode::OK); // read current state of the actor. let res = fvm_sdk::send::send( \u0026amp;Address::new_id(basic_actor_id), method_hash!(\u0026quot;Read\u0026quot;), None, TokenAmount::zero(), None, SendFlags::empty(), ) .unwrap(); // Assert message went through. assert_eq!(res.exit_code, ExitCode::OK); // Deserialize value. let value: u64 = RawBytes::new( res.return_data .expect(\u0026quot;Should be able to get result from HelloWorld of target actor\u0026quot;) .data, ) .deserialize() .unwrap(); // Assert the current state value is the same as we set it to be, as we added to 0. assert_eq!(value, to_add); } Test Fail method: TestFailAddArgumentType #The last test method we will be adding differs from the previous one. In this case, Kythera expects the transaction to end with an exit non-equal to 0. In other words, something should go wrong in the transaction.
In our case, we want to ensure that if we pass a message payload that contains arguments of a non-supported type our actor should fail.
Let\u0026rsquo;s add the TestFailAddArgumentType() method and its invoke() match variant:
#[no_mangle] fn invoke(input: u32) -\u0026gt; u32 { std::panic::set_hook(Box::new(|info| { fvm_sdk::vm::exit( ExitCode::USR_ASSERTION_FAILED.value(), None, Some(\u0026amp;format!(\u0026quot;{info}\u0026quot;)), ) })); let method_num = fvm_sdk::message::method_number(); match_method!( method_num, { \u0026quot;TestAdd\u0026quot; =\u0026gt; { TestAdd(input); NO_DATA_BLOCK_ID }, \u0026quot;TestFailAddArgumentType\u0026quot; =\u0026gt; { TestFailAddArgumentType(input); NO_DATA_BLOCK_ID }, _ =\u0026gt; { fvm_sdk::vm::abort( ExitCode::USR_UNHANDLED_MESSAGE.value(), Some(\u0026quot;Unknown method number\u0026quot;), ); } } ) } // ... // Tests that the actor fails if it receives a payload of a non supported type for its method. #[allow(non_snake_case)] fn TestFailAddArgumentType(input: u32) { // Get basic actor ID. let basic_actor_id: u64 = deserialize_params(input); // Value to add to state. let to_add: Option\u0026lt;\u0026amp;str\u0026gt; = None; // Send message with a wrongly typed payload. let res = fvm_sdk::send::send( \u0026amp;Address::new_id(basic_actor_id), method_hash!(\u0026quot;Add\u0026quot;), Some(IpldBlock::serialize(DAG_CBOR, \u0026amp;to_add).unwrap()), TokenAmount::zero(), None, SendFlags::empty(), ) .unwrap(); // This assertion should panic as our message must have failed assert_eq!(res.exit_code, ExitCode::OK); } Run tests #Now that everything is set up for our actors to be compiled and tested, let\u0026rsquo;s try it!
\$ cargo build Finished dev [unoptimized + debuginfo] target(s) in 1.89s \$ kythera test ./artifacts Running Tests for Actor : BasicActor.wasm Testing 1 test files BasicActor.t.wasm: testing 2 tests test TestAdd ... ok (gas consumption: 4639960) test TestFailAddArgumentType ... ok (gas consumption: 2500193) test result: ok. 2 passed; 0 failed It\u0026rsquo;s a success! Our actor works as intended, and we could even ensure it through tests. This is the end of this basic tutorial on how to start your own Rust native actors project using Kythera.
If you have any comment or recommendation on how to evolve this tutorial to make it even better for newcomers, do not hesitate to refer to our contributing section!
`}),e.add({id:23,href:"/kythera/docs/appendix/",title:"Appendix",description:"",content:""}),e.add({id:24,href:"/kythera/docs/appendix/contributing/",title:"Contributing",description:`Thanks for your interest in improving Kythera!
There are multiple opportunities to contribute at any level. It doesn\u0026rsquo;t matter if you are just getting started with Rust or are the most weathered expert, we can use your help.
No contribution is too small and all contributions are valued.
The best way to make a contribution would be to open an issue related to a problem that you have faced or open a new PR with your suggested changes.`,content:`Thanks for your interest in improving Kythera!
There are multiple opportunities to contribute at any level. It doesn\u0026rsquo;t matter if you are just getting started with Rust or are the most weathered expert, we can use your help.
No contribution is too small and all contributions are valued.
The best way to make a contribution would be to open an issue related to a problem that you have faced or open a new PR with your suggested changes.
Eager to see what you have in store for us!
`}),e.add({id:25,href:"/kythera/docs/",title:"Docs",description:"",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()